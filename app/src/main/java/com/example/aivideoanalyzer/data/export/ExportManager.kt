package com.example.aivideoanalyzer.data.export

import com.example.aivideoanalyzer.domain.model.AnalysisResult
import com.opencsv.CSVWriter
import java.io.File
import java.io.FileWriter
import java.text.SimpleDateFormat
import java.util.*

class ExportManager {

    private val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

    /**
     * Export F3Set analysis results to CSV format with enhanced metadata
     */
    fun exportToCsv(result: AnalysisResult, outputFile: File): Result<File> {
        return try {
            CSVWriter(FileWriter(outputFile)).use { writer ->
                // Write metadata header
                writer.writeNext(arrayOf("# F3Set Tennis Analysis Export"))
                writer.writeNext(arrayOf("# Generated by AI Video Analyzer"))
                writer.writeNext(arrayOf("# Export Date: ${dateFormat.format(Date())}"))
                writer.writeNext(arrayOf("# Video ID: ${result.videoId}"))
                writer.writeNext(arrayOf("# Analysis Date: ${dateFormat.format(result.timestamp)}"))
                writer.writeNext(arrayOf("# Overall Confidence: ${String.format("%.4f", result.confidence)}"))
                writer.writeNext(arrayOf()) // Empty line

                // Write frame data headers
                writer.writeNext(arrayOf(
                    "Frame Number",
                    "Timestamp (ms)",
                    "Action Type",
                    "Confidence",
                    "Bounding Box X",
                    "Bounding Box Y",
                    "Bounding Box Width",
                    "Bounding Box Height",
                    "Frame Confidence"
                ))

                // Write frame detection data
                result.frames.forEach { frame ->
                    frame.detections.forEach { detection ->
                        val bbox = detection.boundingBox
                        writer.writeNext(arrayOf(
                            frame.frameNumber.toString(),
                            frame.timestamp.toString(),
                            detection.label,
                            String.format("%.4f", detection.confidence),
                            bbox?.x?.toString() ?: "",
                            bbox?.y?.toString() ?: "",
                            bbox?.width?.toString() ?: "",
                            bbox?.height?.toString() ?: "",
                            String.format("%.4f", frame.confidence)
                        ))
                    }
                }

                // Write summary section
                writer.writeNext(arrayOf()) // Empty line
                writer.writeNext(arrayOf("# ANALYSIS SUMMARY"))
                writer.writeNext(arrayOf("Video ID", result.videoId))
                writer.writeNext(arrayOf("Analysis Date", dateFormat.format(result.timestamp)))
                writer.writeNext(arrayOf("Overall Confidence", String.format("%.4f", result.confidence)))
                writer.writeNext(arrayOf("Total Frames Analyzed", result.frames.size.toString()))
                writer.writeNext(arrayOf("Total Shot Detections", result.frames.count { it.detections.isNotEmpty() }.toString()))

                // Action type statistics
                val actionStats = result.frames.flatMap { it.detections }
                    .groupBy { it.label }
                    .mapValues { it.value.size }
                    .toList()
                    .sortedByDescending { it.second }

                writer.writeNext(arrayOf()) // Empty line
                writer.writeNext(arrayOf("# ACTION TYPE DISTRIBUTION"))
                writer.writeNext(arrayOf("Action Type", "Count", "Percentage"))
                val totalDetections = result.frames.sumOf { it.detections.size }
                actionStats.forEach { (action, count) ->
                    val percentage = if (totalDetections > 0) (count * 100.0 / totalDetections) else 0.0
                    writer.writeNext(arrayOf(action, count.toString(), String.format("%.2f%%", percentage)))
                }

                // Write confidence statistics with corrected calculation
                if (result.frames.isNotEmpty()) {
                    writer.writeNext(arrayOf()) // Empty line
                    writer.writeNext(arrayOf("# CONFIDENCE STATISTICS"))
                    val detectionConfidences = result.frames.flatMap { it.detections }.map { it.confidence }
                    if (detectionConfidences.isNotEmpty()) {
                        writer.writeNext(arrayOf("Metric", "Value"))
                        writer.writeNext(arrayOf("Average Detection Confidence", String.format("%.4f", detectionConfidences.average())))
                        writer.writeNext(arrayOf("Max Detection Confidence", String.format("%.4f", detectionConfidences.maxOrNull() ?: 0f)))
                        writer.writeNext(arrayOf("Min Detection Confidence", String.format("%.4f", detectionConfidences.minOrNull() ?: 0f)))
                        writer.writeNext(arrayOf("Calculated Overall Confidence", String.format("%.4f", detectionConfidences.average())))
                        writer.writeNext(arrayOf("Original Model Confidence", String.format("%.4f", result.confidence)))
                    }
                }
            }

            Result.success(outputFile)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Export F3Set analysis results to HTML format with enhanced styling and interactivity
     */
    fun exportToHtml(result: AnalysisResult, outputFile: File): Result<File> {
        return try {
            val html = buildString {
                appendLine("<!DOCTYPE html>")
                appendLine("<html>")
                appendLine("<head>")
                appendLine("<meta charset='utf-8'>")
                appendLine("<meta name='viewport' content='width=device-width, initial-scale=1'>")
                appendLine("<title>F3Set Tennis Analysis Report - ${result.videoId}</title>")
                appendLine("<style>")
                appendLine("""
                    * { margin: 0; padding: 0; box-sizing: border-box; }
                    body { 
                        font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; 
                        line-height: 1.6; 
                        color: #2c3e50; 
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        min-height: 100vh;
                        padding: 20px;
                    }
                    .container { 
                        max-width: 1200px; 
                        margin: 0 auto; 
                        background: white; 
                        border-radius: 20px; 
                        box-shadow: 0 20px 40px rgba(0,0,0,0.1);
                        overflow: hidden;
                    }
                    .header {
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        padding: 40px;
                        text-align: center;
                        position: relative;
                        overflow: hidden;
                    }
                    .header::before {
                        content: '';
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="2" fill="rgba(255,255,255,0.1)"/></svg>') repeat;
                        opacity: 0.3;
                    }
                    .header h1 {
                        font-size: 2.5em;
                        margin-bottom: 10px;
                        position: relative;
                        z-index: 2;
                    }
                    .header .subtitle {
                        font-size: 1.2em;
                        opacity: 0.9;
                        position: relative;
                        z-index: 2;
                    }
                    .content { padding: 40px; }
                    .stats-grid { 
                        display: grid; 
                        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
                        gap: 30px; 
                        margin: 30px 0; 
                    }
                    .stat-card { 
                        background: linear-gradient(135deg, #fff, #f8f9fa); 
                        padding: 25px; 
                        border-radius: 15px; 
                        border: 1px solid #e9ecef; 
                        text-align: center;
                        transition: all 0.3s ease;
                        position: relative;
                        overflow: hidden;
                    }
                    .stat-card:hover {
                        transform: translateY(-5px);
                        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
                    }
                    .stat-card h3 {
                        color: #6c757d;
                        font-size: 0.9em;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                        margin-bottom: 10px;
                    }
                    .stat-card .value {
                        font-size: 2.5em;
                        font-weight: bold;
                        color: #495057;
                        margin-bottom: 5px;
                    }
                    .stat-card .label {
                        font-size: 0.85em;
                        color: #6c757d;
                    }
                    .section { margin: 40px 0; }
                    .section h2 { 
                        color: #495057; 
                        border-bottom: 3px solid #667eea; 
                        padding-bottom: 15px; 
                        margin-bottom: 25px;
                        font-size: 1.5em;
                    }
                    .summary-card {
                        background: linear-gradient(135deg, #e8f5e8, #d4edda);
                        padding: 30px;
                        border-radius: 15px;
                        border-left: 5px solid #28a745;
                        margin: 20px 0;
                        white-space: pre-line;
                        line-height: 1.8;
                    }
                    table { 
                        width: 100%; 
                        border-collapse: collapse; 
                        margin: 20px 0; 
                        background: white;
                        border-radius: 10px;
                        overflow: hidden;
                        box-shadow: 0 5px 15px rgba(0,0,0,0.08);
                    }
                    th, td { 
                        padding: 15px; 
                        text-align: left; 
                        border-bottom: 1px solid #dee2e6;
                    }
                    th { 
                        background: linear-gradient(135deg, #667eea, #764ba2); 
                        color: white; 
                        font-weight: 600;
                        text-transform: uppercase;
                        letter-spacing: 0.5px;
                        font-size: 0.85em;
                    }
                    tr:hover { background-color: #f8f9fa; }
                    .confidence { font-weight: bold; font-size: 1.1em; }
                    .high-confidence { color: #28a745; }
                    .medium-confidence { color: #ffc107; }
                    .low-confidence { color: #dc3545; }
                    .shot-timeline { 
                        background: #f8f9fa; 
                        padding: 20px; 
                        border-radius: 15px; 
                        margin: 20px 0;
                    }
                    .shot-item { 
                        background: white; 
                        margin: 15px 0; 
                        padding: 20px; 
                        border-radius: 10px; 
                        border-left: 4px solid #667eea;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
                        transition: all 0.3s ease;
                    }
                    .shot-item:hover {
                        transform: translateX(5px);
                        box-shadow: 0 5px 20px rgba(0,0,0,0.1);
                    }
                    .timestamp { 
                        font-weight: bold; 
                        color: #667eea; 
                        font-size: 1.1em;
                        margin-bottom: 10px;
                    }
                    .action-tag { 
                        display: inline-block; 
                        background: linear-gradient(135deg, #667eea, #764ba2); 
                        color: white; 
                        padding: 6px 12px; 
                        border-radius: 20px; 
                        font-size: 0.85em; 
                        margin: 4px 2px;
                        font-weight: 500;
                    }
                    .footer {
                        background: #f8f9fa;
                        padding: 30px;
                        text-align: center;
                        color: #6c757d;
                        border-top: 1px solid #dee2e6;
                    }
                    .progress-bar {
                        background: #e9ecef;
                        height: 8px;
                        border-radius: 4px;
                        overflow: hidden;
                        margin: 5px 0;
                    }
                    .progress-fill {
                        height: 100%;
                        background: linear-gradient(90deg, #667eea, #764ba2);
                        transition: width 0.3s ease;
                    }
                    @media (max-width: 768px) {
                        .container { margin: 10px; border-radius: 10px; }
                        .header { padding: 20px; }
                        .header h1 { font-size: 2em; }
                        .content { padding: 20px; }
                        .stats-grid { grid-template-columns: 1fr; gap: 20px; }
                        .stat-card { padding: 20px; }
                    }
                """.trimIndent())
                appendLine("</style>")
                appendLine("</head>")
                appendLine("<body>")
                appendLine("<div class='container'>")

                // Enhanced Header
                appendLine("<div class='header'>")
                appendLine("<h1>F3Set Tennis Analysis</h1>")
                appendLine("<div class='subtitle'>Professional Tennis Action Recognition Report</div>")
                appendLine("</div>")

                appendLine("<div class='content'>")

                // Enhanced Stats Grid
                appendLine("<div class='stats-grid'>")
                appendLine("<div class='stat-card'>")
                appendLine("<h3>Video Analysis</h3>")
                appendLine("<div class='value'>${result.videoId}</div>")
                appendLine("<div class='label'>Video ID</div>")
                appendLine("</div>")

                appendLine("<div class='stat-card'>")
                appendLine("<h3>Analysis Date</h3>")
                appendLine("<div class='value'>${dateFormat.format(result.timestamp).split(" ")[0]}</div>")
                appendLine("<div class='label'>${dateFormat.format(result.timestamp).split(" ")[1]}</div>")
                appendLine("</div>")

                // Calculate proper confidence (average of detection confidences, not frame confidence)
                val detectionConfidences = result.frames.flatMap { frame ->
                    frame.detections.map { it.confidence }
                }
                val calculatedConfidence = if (detectionConfidences.isNotEmpty()) {
                    detectionConfidences.average().toFloat()
                } else {
                    result.confidence
                }

                appendLine("<div class='stat-card'>")
                appendLine("<h3>Overall Confidence</h3>")
                appendLine("<div class='value confidence ${getConfidenceClass(calculatedConfidence)}'>${String.format("%.1f", calculatedConfidence * 100)}%</div>")
                appendLine("<div class='label'>AI Confidence Score</div>")
                appendLine("</div>")

                val totalShots = result.frames.count { it.detections.isNotEmpty() }
                appendLine("<div class='stat-card'>")
                appendLine("<h3>Shots Detected</h3>")
                appendLine("<div class='value'>$totalShots</div>")
                appendLine("<div class='label'>Tennis Actions</div>")
                appendLine("</div>")
                appendLine("</div>")

                // Enhanced Summary Section
                appendLine("<div class='section'>")
                appendLine("<h2>Analysis Summary</h2>")
                appendLine("<div class='summary-card'>")
                appendLine(result.summary)
                appendLine("</div>")
                appendLine("</div>")

                // Enhanced Shot Timeline
                if (result.frames.isNotEmpty()) {
                    appendLine("<div class='section'>")
                    appendLine("<h2>Shot Detection Timeline</h2>")
                    appendLine("<div class='shot-timeline'>")

                    result.frames.forEach { frame ->
                        if (frame.detections.isNotEmpty()) {
                            val timeStr = formatMilliseconds(frame.timestamp)
                            appendLine("<div class='shot-item'>")
                            appendLine("<div class='timestamp'>Frame ${frame.frameNumber} • ${timeStr}</div>")
                            frame.detections.sortedByDescending { it.confidence }.forEach { detection ->
                                appendLine("<span class='action-tag'>${detection.label} (${String.format("%.1f", detection.confidence * 100)}%)</span>")
                            }
                            appendLine("</div>")
                        }
                    }
                    appendLine("</div>")
                    appendLine("</div>")
                }

                // Enhanced Detailed Frame Analysis Table
                appendLine("<div class='section'>")
                appendLine("<h2>Detailed Frame Analysis</h2>")
                appendLine("<table>")
                appendLine("<tr><th>Frame</th><th>Time</th><th>Action</th><th>Confidence</th><th>Bounding Box</th></tr>")

                result.frames.forEach { frame ->
                    frame.detections.forEach { detection ->
                        val bbox = detection.boundingBox
                        val bboxStr = if (bbox != null) {
                            "x:${String.format("%.0f", bbox.x)}, y:${String.format("%.0f", bbox.y)}, w:${String.format("%.0f", bbox.width)}, h:${String.format("%.0f", bbox.height)}"
                        } else {
                            "N/A"
                        }

                        appendLine("<tr>")
                        appendLine("<td>${frame.frameNumber}</td>")
                        appendLine("<td>${formatMilliseconds(frame.timestamp)}</td>")
                        appendLine("<td>${detection.label}</td>")
                        appendLine("<td class='confidence ${getConfidenceClass(detection.confidence)}'>${String.format("%.2f", detection.confidence * 100)}%</td>")
                        appendLine("<td style='font-family: monospace; font-size: 0.9em;'>$bboxStr</td>")
                        appendLine("</tr>")
                    }
                }
                appendLine("</table>")
                appendLine("</div>")

                // Enhanced Action Statistics
                val actionCounts = result.frames.flatMap { it.detections }
                    .groupBy { it.label }
                    .mapValues { entry ->
                        Pair(entry.value.size, entry.value.map { it.confidence }.average().toFloat())
                    }
                    .toList()
                    .sortedByDescending { it.second.first }

                if (actionCounts.isNotEmpty()) {
                    appendLine("<div class='section'>")
                    appendLine("<h2>Action Type Statistics</h2>")
                    appendLine("<table>")
                    appendLine("<tr><th>Action Type</th><th>Occurrences</th><th>Avg Confidence</th><th>Distribution</th></tr>")
                    val maxCount = actionCounts.maxOfOrNull { it.second.first } ?: 1
                    actionCounts.forEach { (action, data) ->
                        val (count, avgConf) = data
                        val percentage = (count * 100.0 / maxCount).toInt()
                        appendLine("<tr>")
                        appendLine("<td>$action</td>")
                        appendLine("<td>$count</td>")
                        appendLine("<td class='confidence ${getConfidenceClass(avgConf)}'>${String.format("%.2f", avgConf * 100)}%</td>")
                        appendLine("<td><div class='progress-bar'><div class='progress-fill' style='width: ${percentage}%'></div></div></td>")
                        appendLine("</tr>")
                    }
                    appendLine("</table>")
                    appendLine("</div>")
                }

                appendLine("</div>")

                // Enhanced Footer
                appendLine("<div class='footer'>")
                appendLine("<p>Generated by <strong>AI Video Analyzer</strong> using F3Set Tennis Action Recognition</p>")
                appendLine("<p>All processing performed locally on device • Export date: ${dateFormat.format(Date())}</p>")
                appendLine("</div>")

                appendLine("</div>")
                appendLine("</body>")
                appendLine("</html>")
            }

            outputFile.writeText(html)
            Result.success(outputFile)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Export F3Set analysis results to JSON format with comprehensive metadata
     */
    fun exportToJson(result: AnalysisResult, outputFile: File): Result<File> {
        return try {
            val json = buildString {
                appendLine("{")
                appendLine("  \"metadata\": {")
                appendLine("    \"generator\": \"AI Video Analyzer - F3Set Tennis Action Recognition\",")
                appendLine("    \"version\": \"1.0.0\",")
                appendLine("    \"exportDate\": \"${dateFormat.format(Date())}\",")
                appendLine("    \"processingType\": \"local_device_processing\"")
                appendLine("  },")
                appendLine("  \"analysisData\": {")
                appendLine("    \"videoId\": \"${result.videoId}\",")
                appendLine("    \"timestamp\": \"${dateFormat.format(result.timestamp)}\",")
                appendLine("    \"confidence\": ${result.confidence},")
                appendLine("    \"summary\": \"${result.summary.replace("\"", "\\\"").replace("\n", "\\n")}\",")
                appendLine("    \"analysisType\": \"F3Set Tennis Action Recognition\",")
                appendLine("    \"totalFrames\": ${result.frames.size},")
                appendLine("    \"totalDetections\": ${result.frames.sumOf { it.detections.size }}")
                appendLine("  },")
                appendLine("  \"frameData\": [")

                result.frames.forEachIndexed { frameIndex, frame ->
                    if (frame.detections.isNotEmpty()) {
                        appendLine("    {")
                        appendLine("      \"frameNumber\": ${frame.frameNumber},")
                        appendLine("      \"timestamp\": ${frame.timestamp},")
                        appendLine("      \"frameConfidence\": ${frame.confidence},")
                        appendLine("      \"detections\": [")

                        frame.detections.forEachIndexed { detIndex, detection ->
                            appendLine("        {")
                            appendLine("          \"action\": \"${detection.label}\",")
                            appendLine("          \"confidence\": ${detection.confidence}")

                            detection.boundingBox?.let { bbox ->
                                appendLine("          ,\"boundingBox\": {")
                                appendLine("            \"x\": ${bbox.x},")
                                appendLine("            \"y\": ${bbox.y},")
                                appendLine("            \"width\": ${bbox.width},")
                                appendLine("            \"height\": ${bbox.height}")
                                appendLine("          }")
                            }

                            append("        }")
                            if (detIndex < frame.detections.size - 1) append(",")
                            appendLine()
                        }

                        appendLine("      ]")
                        append("    }")
                        if (frameIndex < result.frames.size - 1 && result.frames.drop(frameIndex + 1).any { it.detections.isNotEmpty() }) {
                            append(",")
                        }
                        appendLine()
                    }
                }

                appendLine("  ],")

                // Enhanced statistics
                val actionStats = result.frames.flatMap { it.detections }
                    .groupBy { it.label }
                    .mapValues { it.value.size }

                val confidenceStats = result.frames.flatMap { it.detections }
                    .map { it.confidence }

                appendLine("  \"statistics\": {")
                appendLine("    \"actionDistribution\": {")
                actionStats.entries.forEachIndexed { index, (action, count) ->
                    append("      \"$action\": $count")
                    if (index < actionStats.size - 1) append(",")
                    appendLine()
                }
                appendLine("    },")

                if (confidenceStats.isNotEmpty()) {
                    appendLine("    \"confidenceStatistics\": {")
                    appendLine("      \"average\": ${confidenceStats.average()},")
                    appendLine("      \"maximum\": ${confidenceStats.maxOrNull() ?: 0f},")
                    appendLine("      \"minimum\": ${confidenceStats.minOrNull() ?: 0f},")
                    appendLine("      \"standardDeviation\": ${calculateStandardDeviation(confidenceStats)},")
                    appendLine("      \"calculatedOverallConfidence\": ${confidenceStats.average()}")
                    appendLine("    },")
                }

                appendLine("    \"processingInfo\": {")
                appendLine("      \"framesWithDetections\": ${result.frames.count { it.detections.isNotEmpty() }},")
                appendLine("      \"totalFramesAnalyzed\": ${result.frames.size},")
                appendLine("      \"averageDetectionsPerFrame\": ${if (result.frames.isNotEmpty()) result.frames.map { it.detections.size }.average() else 0.0},")
                appendLine("      \"uniqueActionTypes\": ${actionStats.keys.size},")
                appendLine("      \"totalIndividualDetections\": ${result.frames.sumOf { it.detections.size }}")
                appendLine("    }")
                appendLine("  }")

                appendLine("}")
            }

            outputFile.writeText(json)
            Result.success(outputFile)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Export multiple results to a consolidated format
     */
    fun exportMultipleResults(results: List<AnalysisResult>, outputFile: File): Result<File> {
        return try {
            val html = buildString {
                appendLine("<!DOCTYPE html>")
                appendLine("<html>")
                appendLine("<head>")
                appendLine("<meta charset='utf-8'>")
                appendLine("<title>F3Set Tennis Analysis - Multiple Results</title>")
                appendLine("<style>")
                appendLine(getConsolidatedReportStyles())
                appendLine("</style>")
                appendLine("</head>")
                appendLine("<body>")

                appendLine("<div class='container'>")
                appendLine("<div class='header'>")
                appendLine("<h1>F3Set Tennis Analysis</h1>")
                appendLine("<div class='subtitle'>Consolidated Analysis Report</div>")
                appendLine("<div class='meta'>Generated: ${dateFormat.format(Date())} • ${results.size} Videos Analyzed</div>")
                appendLine("</div>")

                appendLine("<div class='content'>")

                // Summary statistics
                appendLine("<div class='section'>")
                appendLine("<h2>Overall Statistics</h2>")
                appendLine("<div class='stats-grid'>")

                val totalFrames = results.sumOf { it.frames.size }
                val totalDetections = results.sumOf { it.frames.sumOf { frame -> frame.detections.size } }
                val avgConfidence = results.map { it.confidence }.average()

                appendLine("<div class='stat-card'>")
                appendLine("<h3>Videos Analyzed</h3>")
                appendLine("<div class='value'>${results.size}</div>")
                appendLine("</div>")

                appendLine("<div class='stat-card'>")
                appendLine("<h3>Total Frames</h3>")
                appendLine("<div class='value'>$totalFrames</div>")
                appendLine("</div>")

                appendLine("<div class='stat-card'>")
                appendLine("<h3>Total Detections</h3>")
                appendLine("<div class='value'>$totalDetections</div>")
                appendLine("</div>")

                appendLine("<div class='stat-card'>")
                appendLine("<h3>Average Confidence</h3>")
                appendLine("<div class='value'>${String.format("%.1f", avgConfidence * 100)}%</div>")
                appendLine("</div>")

                appendLine("</div>")
                appendLine("</div>")

                // Individual results
                appendLine("<div class='section'>")
                appendLine("<h2>Individual Analysis Results</h2>")

                results.forEachIndexed { index, result ->
                    appendLine("<div class='result-card'>")
                    appendLine("<h3>Video ${index + 1}: ${result.videoId}</h3>")
                    appendLine("<div class='result-meta'>")
                    appendLine("Analysis Date: ${dateFormat.format(result.timestamp)} • ")
                    appendLine("Confidence: ${String.format("%.1f", result.confidence * 100)}% • ")
                    appendLine("Frames: ${result.frames.size} • ")
                    appendLine("Detections: ${result.frames.sumOf { it.detections.size }}")
                    appendLine("</div>")
                    appendLine("<div class='result-summary'>${result.summary}</div>")
                    appendLine("</div>")
                }

                appendLine("</div>")
                appendLine("</div>")
                appendLine("</div>")

                appendLine("</body>")
                appendLine("</html>")
            }

            outputFile.writeText(html)
            Result.success(outputFile)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    private fun getConfidenceClass(confidence: Float): String {
        return when {
            confidence >= 0.8f -> "high-confidence"
            confidence >= 0.6f -> "medium-confidence"
            else -> "low-confidence"
        }
    }

    private fun formatMilliseconds(ms: Long): String {
        val seconds = ms / 1000
        val minutes = seconds / 60
        val remainingSeconds = seconds % 60
        val milliseconds = ms % 1000
        return String.format("%d:%02d.%03d", minutes, remainingSeconds, milliseconds)
    }

    private fun calculateStandardDeviation(values: List<Float>): Float {
        if (values.isEmpty()) return 0f
        val mean = values.average()
        val variance = values.map { (it - mean) * (it - mean) }.average()
        return kotlin.math.sqrt(variance).toFloat()
    }

    private fun getConsolidatedReportStyles(): String {
        return """
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body { font-family: 'Segoe UI', system-ui, sans-serif; line-height: 1.6; color: #2c3e50; background: #f5f6fa; }
            .container { max-width: 1200px; margin: 20px auto; background: white; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
            .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 40px; text-align: center; border-radius: 15px 15px 0 0; }
            .header h1 { font-size: 2.5em; margin-bottom: 10px; }
            .subtitle { font-size: 1.2em; opacity: 0.9; margin-bottom: 10px; }
            .meta { font-size: 0.9em; opacity: 0.8; }
            .content { padding: 40px; }
            .section { margin: 30px 0; }
            .section h2 { color: #495057; border-bottom: 2px solid #667eea; padding-bottom: 10px; margin-bottom: 20px; }
            .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }
            .stat-card { background: linear-gradient(135deg, #fff, #f8f9fa); padding: 20px; border-radius: 10px; text-align: center; border: 1px solid #e9ecef; }
            .stat-card h3 { color: #6c757d; font-size: 0.9em; margin-bottom: 10px; }
            .stat-card .value { font-size: 2em; font-weight: bold; color: #495057; }
            .result-card { background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 15px 0; border-left: 4px solid #667eea; }
            .result-card h3 { color: #495057; margin-bottom: 10px; }
            .result-meta { color: #6c757d; font-size: 0.9em; margin-bottom: 10px; }
            .result-summary { white-space: pre-line; line-height: 1.6; }
        """.trimIndent()
    }
}